using core::mem::{size_of, malloc, realloc, free};

struct Vector<type T> {
	T mut* data;
	usize len;
	usize capacity;

	init(init& self) {
		// Literal initialization - move elision guaranteed
		self = Vector {
			data: nullptr,
			len: 0,
			capacity: 0,
		};
	}
	
	drop(mut& self) {
		if self.capacity > 0 {
			for (usize i = 0; i < self.len; i++) {
				*(self.data + i).~T();
			}

			free(self.data as void mut*);
		}
	}
}

using Test = Vector<int>;

void foo() {
	Test a = Vector<int>();
	// God this could use some syntactic sugar lol
	usize size = size_of<Test>();
	Test mut* b = malloc(size) as Test mut*;

	// Direct constructor call - equivalent of C++'s placement-new
	(*b).init();
}

@no_mangle
int printf(u8* fmt, ...);



impl<type T> Vector<T> {

	void push(mut& self, T elem) {		
		if self.len >= self.capacity {
			self.realloc(
				if self.capacity == 0 { 
					self.capacity + 1 
				} else { 
					self.capacity * 2
				}
			)
		}
		
		unsafe {
			*(self.data + self.len) = elem
		}
		
		self.len += 1;
	}

	void realloc(mut& self, usize capacity) {		
		self.data = realloc(
				self.data as void mut*, 
				capacity * size_of<T>()
			) as T mut*;
		
		self.capacity = capacity;
	}

	T get(mut& self, usize i) {
		unsafe { *(self.data + i) }
	}

}

impl<type T> Drop for Vector<T> {
	void drop(mut& self) {
		printf(c"<Vector<T> as Drop>::drop() called!\n");
	
		if self.capacity > 0 {
			free(self.data as void mut*);
		}
	}
}

void vector_test(Vector<float> test) {
	test.push(12.0f);
	test.push(24.0f);
}