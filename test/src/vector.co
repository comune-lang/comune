using core::mem::{size_of, malloc, realloc, free};

struct Vector<type T> {
	T mut* data;
	usize len;
	usize capacity;
}

@no_mangle
int printf(u8* fmt, ...);



impl<type T> Vector<T> {

	void push(mut& self, T elem) {
		printf(c"Pushing... new size: %lu\n", self.len + 1);
		
		if self.len >= self.capacity {
			if self.capacity == 0 {
				self.realloc(1);
			} else {
				self.realloc(self.capacity * 2);
			}
		}
		
		printf(c"self.data: %p\n", self.data);
		printf(c"self.data + self.len: %p\n", self.data + self.len);
		printf(c"self.data + self.capacity: %p\n", self.data + self.capacity);

		unsafe {
			*(self.data + self.len) = elem;
		}
		
		printf(c"data written!\n");

		self.len += 1;
	}

	void realloc(mut& self, usize capacity) {
		printf(c"Reallocating... new capacity: %lu\n", capacity);
		
		self.data = realloc(
				self.data as void mut*, 
				capacity * size_of<T>()
			) as T mut*;
		
		self.capacity = capacity;
	}

	// TODO: Implement returning references with `self` lifetime
	T get(mut& self, usize i) {
		unsafe { *(self.data + i) }
	}

}

void vector_test(Vector<float> test) {
	test.push(12.0f);
	test.push(24.0f)
}