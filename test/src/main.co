struct Vector<type T> {
	T mut* data;
	usize len;
	usize capacity;
}

@no_mangle
void mut* malloc(usize size);

@no_mangle
void free(void mut* ptr);

impl<type T> Vector<T> {
	Vector<T> new() {
		Vector<T> {
			data: malloc(0) as T mut*,
			len: 0,
			capacity: 0,
		}
	}

	void push(mut& self, T elem) {
		self.len += 1;
		
		if self.len > self.capacity {
			self.realloc<T>(self.capacity * 2);
		}
	}

	void realloc(mut& self, usize capacity) {
		// TODO: Implement sizeof(T)
		T mut* mut new_storage = malloc(capacity) as T mut*;
		
		for (usize mut i = 0; i < self.len; i++) {
			unsafe { 
				*(new_storage + i) = *(self.data + i);
			}
		}

		free(self.data as void mut*);
		self.data = new_storage;
	}

	// TODO: Implement returning references with `self` lifetime
	T get(mut& self, usize i) {
		unsafe { *(self.data + i) }
	}
}
