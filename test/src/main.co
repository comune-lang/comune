struct Vector<type T> {
	T mut* data;
	usize len;
	usize capacity;
}

@no_mangle
void mut* malloc(usize size);

@no_mangle
void free(void mut* ptr);

@no_mangle
void printf(u8* fmt, ...);


usize stride_of<type T>() {
	T* ptr1 = malloc(0) as T*;
	T* ptr2 = ptr1 + 1;

	unsafe {
		usize addr1 = *(&ptr1 as usize*);
		usize addr2 = *(&ptr2 as usize*);
		addr2-addr1
	}
}

impl<type T> Vector<T> {

	void push(mut& self, T elem) {
		printf(c"Pushing %i... new size: %i\n", elem, self.len + 1);
		
		if self.len >= self.capacity {
			if self.capacity == 0 {
				self.realloc(1);
			} else {
				self.realloc(self.capacity * 2);
			}
		}
		printf(c"self.data: %i\n", self.data);
		printf(c"self.data + self.len: %i\n", self.data + self.len);

		unsafe {
			*(self.data + self.len) = elem;
		}

		self.len += 1;
	}

	void realloc(mut& self, usize capacity) {
		printf(c"Reallocating... new capacity: %i\n", capacity);

		T mut* mut new_storage = malloc(capacity * stride_of<T>()) as T mut*;
		
		for (usize mut i = 0; i < self.len; i++) {
			unsafe { 
				*(new_storage + i) = *(self.data + i);
			}
		}
		
		free(self.data as void mut*);
		self.data = new_storage;
		self.capacity = capacity;
	}

	// TODO: Implement returning references with `self` lifetime
	T get(mut& self, usize i) {
		unsafe { *(self.data + i) }
	}

}


int main() {
	Vector<i32> mut test = Vector<i32> {
		data: malloc(0) as i32 mut*,
		len: 0,
		capacity: 0,
	};
	
	i32 a = 0;
	printf(c"stride_of i32: %i\n", stride_of<i32>());

	test.push(413);
	test.push(612);
	
	printf(c"test.get(0) = %i\n", test.get(0));
	printf(c"test.get(1) = %i\n", test.get(1));
	0
}