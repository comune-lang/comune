using core::libc::{malloc, free, printf};
using core::mem::{bit_cast, size_of};
using core::option::Option;
using std::vector::Vector;
using std::rc::Rc;

using module_test::fib;
using ascii = u8;

import module_test;
//import cpp_test;

module submodule_test;

struct Test {
	int a;
	int b;
}

enum EnumTest {
	VariantA,
	VariantB,
}

impl Test {
	int sum(Test& self) {
		printf(c"This is a method call!\n");
		self.a + self.b
	}
	
	// the `self` parameter's type can be omitted
	int product(&self) {
		self.a * self.b
	}
}

type NestedGenerics = Vector<Vector<Vector<Vector<Vector<int>>>>>;

impl submodule_test::SubmoduleTrait for Test {
	void foo() {
		printf(c"This is a trait in a submodule!\n");
	}
}

trait Hello {
	void hello(&self);
}

impl Hello for Test {
	void hello(&self) {
		printf(c"Hello Test!\n");
	}
}


void impl_test() {
	Test test = new Test { a: 413, b: 612, };
	test.hello();
	printf(c"The sum of a and b is %i!\n", test.sum());
}

void ref_test(i32 mut& test) {
	test += 1;
}

void fn_pointer_test(void(int) callback) {
	callback(12);
}

void fn_pointer_callback(int number) {
	printf(c"this is a callback! %i\n", number);
}


void overload_test(i32 a) {
	printf(c"i32 overload called!\n");
}

void overload_test(i64 a) {
	printf(c"i64 overload called!\n");
}

type GenericTypeAlias<type T> = Vector<T>;

Vector<i32> generic_ret() {
	new GenericTypeAlias<i32>()
}

type TestSumType = (i32 | f32);

TestSumType sum_type_test(i32 value) {
	return value;
}

struct Slice<type T> {
	T* t;
	usize len;
}

fn slice_test(i32[]* test) {
	auto slice = &test as Slice<i32>*;

	printf(c"Slice length: %i\n", slice->len);
}


struct DropTest {
	int num;
	int raw* allocation;

	drop(mut& self) {
		printf(c"DropTest no. %i dropped\n", self.num);
		free(self.allocation as void raw*)
	}

	new(new& self, int num) {
		printf(c"DropTest no. %i created!\n", num);

		self = new DropTest {
			num,
			allocation: malloc(4) as int raw*,
		}
	}
}

impl DropTest {
	void consume(Self self) {
		printf(c"Consuming DropTest %i\n", self.num);
	}
}

void temp_drop_test(DropTest& test) {
	printf(c"temp_drop_test(DropTest&) called\n");
}

void drop_test() {
	printf(c"\nEntering drop_test\n\n");
	sub_drop_test();
	printf(c"Left drop_test\n\n");
}

void memberwise_init_test(DropTest new& test) {
	test.num = -1;
	test.allocation = malloc(4) as int raw*;
}

void sub_drop_test() {
	DropTest a = new DropTest(1);
	DropTest b = new DropTest(2);

	printf(c"\nEntering subscope\n\n");
	{
		DropTest c = new DropTest(3);
		
		int mut i = 0;
		
		printf(c"\nEntering loop\n\n");

		while i < 5 {
			DropTest b = new DropTest(4);

			if i == 4 {
				break
			}

			i += 1;
		}

		printf(c"\nLeft loop\n\n");

	}
	printf(c"\nLeft subscope\n\n");

	printf(c"\nVector<DropTest> test:\n\n");

	{
		Vector<DropTest> mut drop_vec = new Vector<DropTest>();
		drop_vec.push(new DropTest(5));
		drop_vec.push(new DropTest(6));
		
		*drop_vec.get_mut(1).unwrap() = new DropTest(7);
	}

	printf(c"\nLeft Vector<DropTest> scope\n\n");

	Option<DropTest> option = new Option<DropTest>::Some(
		new DropTest(8)
	);

	temp_drop_test(new DropTest(9));

	new DropTest(10).consume();
}

void new_ref_test(Vector<float> new& test) {
	test = new Vector<float>();
}

void mut_move_test(Vector<float> mut& test) {
	// move out of mut* - legal, but...
	Vector<float> tmp = test;

	// we have to make sure it's initialized
	// by the end of the function. commenting 
	// out this line would raise a compile error 
	test = tmp;
}

type None<type T> = Option<T>::None;
type Some<type T> = Option<T>::Some;

void enum_test() {
	Option<i32> mut option = new None<i32>;
	
	option = new Some<i32> {
		value: 23,
	};

	match option {
		None<i32> none => { 
			printf(c"It's the None variant!");
		}

		Some<i32> some => {
			printf(c"It's the Some(%i) variant!", some.value);
		}
	}

	Option<i32> mut option = new Some<i32>(1);

	i32 unwrapped = option.unwrap();

	option = new None<i32>;
	
	//option.unwrap();
}

void ops_test() {
	u8 mut bitwise_test = 0xFF;
	bitwise_test &= 0x0Fu8;
	bitwise_test <<= 2;
	bitwise_test >>= 1;
	bitwise_test |= 0;
	bitwise_test ^= 1;

	printf(c"value of bitwise_test: %i\n", bitwise_test);

	bool this_value = !true;

	printf(c"this_value is %s!\n", if this_value {
		c"true"
	} else {
		c"false"
	});
}

void rc_test() {
	printf(c"Creating Rc<DropTest>!\n");
	auto rc = new Rc<DropTest>(new DropTest(0));
	
	for (int mut i = 0; i < 10; i += 1) {
		printf(c"Cloning Rc<DropTest>!\n");
		Rc<auto> rc = new Rc<DropTest>(rc);
		printf(c"Dropping Rc<DropTest>!\n");
	}
	printf(c"Dropping last Rc<DropTest>!\n");
}

struct DerefTest {
	int a;
}

void ptr_access_test() {
	auto mut a = new DerefTest {
		a: 0
	};
	
	auto mut b = &mut a;
	auto mut c = &mut b;
	auto mut d = &mut c;
	
	b->a = 1;
	c->>a = 2;
	d->>>a = 3;
}


int global_var;

void global_var_test() {
	global_var = 0;
}

int main() {
	ops_test();
	enum_test();
	drop_test();
	rc_test();

	global_var_test();
	printf(c"Global var: %i\n", global_var);

	auto slice = new Slice<i32> {
		t: core::mem::null<i32>() as i32*,
		len: 1,
	};

	slice_test(*(&slice as i32[]**));

	submodule_test::bar();
	printf(c"fib(10) = %i\n", module_test::fib(10));

	Vector<float> mut a;
	
	new_ref_test(a);

	a.push(12.0f);

	if true {
		drop a;
	}

	int i;

	if true {
		i = 12;
	} else {
		i = 12;
	}

	int mut i = i;

	int i = 12;

	{
		int explicit_scope_test = 23;
	}

	// `else if` syntax test
	
	if i == 12 {
		int scope_test = 15;
		int scope_test_2 = 15;
		printf(c"i is 12!\n");
	} else if i == 13 {
		printf(c"i is 13!\n");
	} else {
		printf(c"i is something else!\n");
	}

	void(int) function;
	//function(12);
	//fn_pointer_test(fn_pointer_callback);
	
	TestSumType mut who_knows = sum_type_test(322);

	match who_knows {
		int int_result => {
			printf(c"It's an int! %i\n", int_result)
		}

		float float_result => {
			printf(c"It's a float! %f\n", float_result)
		}
	}
	
	int mut loop_count = 0;
	
	while true {		
		loop_count += 1;

		if loop_count > 100 {
			int loop_init_test = 12;
			break;
		}
	}

	printf(c"Loop count after loop: %i\n", loop_count);
	
	impl_test();

	overload_test(12i32);

	int int_ref_test = 12;
	ref_test(int_ref_test);
	printf(c"int_ref_test: %i\n", int_ref_test);

	printf(c"Temporary->lvalue promotion: %i\n", new Test { a: 23, b: 35 }.sum());
	
	unsafe {
		printf(c"bit_cast<f32, u32>: %i\n", bit_cast<f32, u32>(10.0f32));
	}

	0
}