import module_test;

using module_test::{fib, foo};

@no_mangle
void* malloc(usize size);

@no_mangle
void free(void* ptr);

using ascii = u8;

@no_mangle
void printf(ascii* fmt, ...);

@layout(packed)
struct Test {
	int a;
	int b;
}

struct Vector<T> {
	T* data;
	usize len;
	usize capacity;
}

impl Test {
	int sum(&mut Test self) {
		printf(c"This is a method call!\n");
		self.a + self.b
	}
}

trait Hello {
	void hello(Self self);
}

impl Hello for Test {
	void hello(&mut Self self) {
		printf(c"Hello Test!\n");
	}
}

void impl_test() {
	Test test = Test { a: 413, b: 612, };
	test.hello();
	printf(c"The sum of a and b is %i!\n", test.sum());
}

void ref_test(&i32 test) {
	&i32 test_var = test;
	test_var++;
}

//void fn_pointer_test(&unsafe mut fn<void(int)> callback) {
//	callback(12);
//}

void overload_test(i32 a) {
	printf(c"i32 overload called!\n");
}

void overload_test(i64 a) {
	printf(c"i64 overload called!\n");
}

Vector<i32> generic_ret() {
	return Vector<i32> {
		data: malloc(4) as i32*,
		len: 1,
		capacity: 1,
	};
}

int main() {
	impl_test();

	overload_test(12i32);

	int int_ref_test = 12;
	ref_test(int_ref_test);
	printf(c"int_ref_test: %i\n", int_ref_test);

	(i64 | f32) who_knows = 322.f;
	
	match who_knows {
		i64 int_result => {
			printf(c"It's an int! %i\n", int_result)
		}

		float float_result => {
			printf(c"It's a float! %f\n", float_result)
		}
	};

	(i64 | i32) int_test = 32 as i32;

	match int_test {
		i32 a => {
			printf(c"It's an i32! %i\n", a)
		}

		i64 b => {
			printf(c"It's an i64! %i\n", b)
		}
	};

	printf(c"who_knows discriminant:%i\n", who_knows);

	printf(c"Temporary->lvalue promotion: %i\n", Test { a: 23, b: 35 }.sum());

	Vector<int> my_cool_generic;

	my_cool_generic.data = malloc(4) as int*;
	
	*my_cool_generic.data = if true {
		printf(c"True!\n");
		69
	} else {
		printf(c"False!\n");
		42
	};
	
	// This fucks with lifeline's liveness check - something to do with sublocation tracking
	i32 generic_get = *my_cool_generic.data;
	*my_cool_generic.data = 69;
	free(my_cool_generic.data as void*);

	return 0;
}