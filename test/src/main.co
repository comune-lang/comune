import module_test;

using module_test::{fib, foo};

@no_mangle
void printf(u8* fmt, ...);

@no_mangle
void* malloc(usize size);

@no_mangle
void free(void* ptr);

@layout(packed)
struct Test {
	int a;
	int b;
}

impl Test {
	int sum(Test self) {
		printf(c"This is a method call!\n");
		self.a + self.b
	}
}

struct Vector<T> {
	T* data;
	usize len;
	usize capacity;
}

int main() {
	printf(c"This is main()!\n");

	(int | float) who_knows = 322.f;
	
	printf(c"It's a float! %f\n", 32.f);
	
	match who_knows {
		int& int_result => {
			printf(c"It's an int: %i\n", int_result);
		}

		float float_result => {
			printf(c"It's a float! %f\n", float_result);
		}
	}

	printf(c"who_knows discriminant:%i\n", who_knows);

	printf(c"Temporary->lvalue promotion: %i\n", Test { a: 23, b: 35 }.sum());

	Vector<int> my_cool_generic;

	my_cool_generic.data = malloc(8) as int*;
	
	*my_cool_generic.data = if true {
		printf(c"True!\n");
		69
	} else {
		printf(c"False!\n");
		42
	};
	
	// This fucks with lifeline's liveness check - something to do with sublocation tracking
	i32 generic_get = *my_cool_generic.data;
	*my_cool_generic.data = 69;

	// Borrowck stuff
	Test test;

	test = Test { 
		a: *my_cool_generic.data, 
		b: 0
	};

	free(my_cool_generic.data as void*);

	test.sum()
	
}