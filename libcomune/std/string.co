using std::vector::Vector;
using core::libc::memcpy;
using std::io::println;

struct String {
	Vector<u8> vec;

	new(new& self) {
		self.vec = new Vector<u8>();
	}

	new(new& self, String& copied) {
		self.vec = new Vector<u8>(copied.vec);
	}
}

impl String {
	fn push_str(mut& self, [u8]* string) {
		auto len = self.len();

		// internal length is one byte longer, since
		// we always store a null-terminator for C/C++
		// compatibility.
		unsafe {
			self.vec.resize_zeroed(len + string->len() + 1);
		}

		auto ptr = self.vec.data + len;
		memcpy(
			ptr as void mut*,
			string->ptr() as void*,
			string->len()
		);
	}

	fn len(&self) -> usize {
		auto len = self.vec.len();
		
		if len == 0 {
			return 0
		} else {
			return len - 1usize
		}
	}

	fn c_str(&self) -> u8* {
		self.vec.data as u8*
	}
}