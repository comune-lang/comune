using core::libc::{
	abort,
	malloc, 
	realloc, 
	free,
	memcpy,
	printf
};

using core::mem::{
	size_of,
	bit_cast, 
	null_mut
};

struct Vector<type T> {
	T mut* data;
	usize len;
	usize capacity;

	new(new& self) {
		self = new Vector<T> {
			data: null_mut<T>(),
			capacity: 0,
			len: 0,
		};
	}

	new(new& self, Vector<T>& copied) {
		self = new Vector<T>();
		
		self.realloc(copied.capacity);
		
		if copied.len == 0 {
			return
		}
		
		memcpy(
			self.data as void mut*, 
			copied.data as void*,
			copied.len
		);

		self.len = copied.len;
	}
	
	drop(mut& self) {		
		if self.capacity > 0 {
			for (usize mut i = 0; i < self.len; i++) {
				unsafe {
					drop *(self.data + i);
				}
			}

			free(self.data as void mut*);
		}
	}
}

impl<type T> Vector<T> {
	void push(mut& self, T elem) {
		printf(c"Entered Vector<T>::push\n");
		if self.len >= self.capacity {
			self.realloc(
				if self.capacity == 0 { 
					self.capacity + 1 
				} else { 
					self.capacity * 2
				}
			)
		}
		
		unsafe {
			printf(c"Calling write\n");
			core::mem::write<T>(
				self.data + self.len,
				elem
			);
			printf(c"Called write\n");
		}
		
		self.len += 1;
		printf(c"Leaving Vector<T>::push\n");
	}

	void realloc(mut& self, usize capacity) {		
		void mut* tmp = realloc(
			self.data as void mut*, 
			capacity * size_of<T>()
		);

		if tmp {
			self.data = tmp as T mut*;
			self.capacity = capacity;
		} else {
			free(self.data as void mut*);
			// TODO: panic here
		}
	}
	
	T& get(&self, usize i) {
		if i >= self.len {
			abort();
		}
		unsafe { *(self.data + i) }
	}

	T mut& get_mut(mut& self, usize i) {
		if i >= self.len {
			abort();
		}
		unsafe { *(self.data + i) }
	}
}
